\section gen_option_index Option index: General options

This section contains a listing of the general options available when running
a ForceBalance job, which go into the $options section.  The general options
are global for the ForceBalance job, in contrast to 'Target options' which apply to one
target within a job (described in the next section).
The option index is generated by running make-option-index.py.

@li <b> ADAPTIVE_DAMPING </b> (Float)
\n<b> One-line description </b>: Damping factor that ties down the trust radius to trust0; decrease for a more variable step size.
\n<b> Default Value </b>: 0.5
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: See documentation for adaptive_factor.
\n<b> Recommendation </b>: A larger value will ensure that the trust radius never exceeds the original value by more
                                      than a small percentage.  0.5 is a reasonable value to start from.

@li <b> ADAPTIVE_FACTOR </b> (Float)
\n<b> One-line description </b>: The step size is increased / decreased by up to this much in the event of a good / bad step; increase for a more variable step size.
\n<b> Default Value </b>: 0.25
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: Adaptive adjustment of the step size in trust-radius Newton Raphson.
                                      If the optimizer takes a good step, the step is increased as follows:
@verbatim
trust += adaptive_factor*trust*np.exp(-adaptive_damping*(trust/self.trust0 - 1))
@endverbatim
                                      Note that the adaptive_damping option makes sure that the trust radius increases by a smaller factor
                                      the further it deviates from the original trust radius (trust0).
                                      On the other hand, if the optimizer takes a bad step, the step is reduced as follows:
@verbatim
trust = max(ndx*(1./(1+adaptive_factor)), self.mintrust)
@endverbatim

\n<b> Recommendation </b>: 0.2 is a conservative value, 0.5 for big step size adjustments.

@li <b> AMOEBA_EPS </b> (Float)
\n<b> One-line description </b>: The AMOEBA mutual polarization criterion.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> AMOEBA_POL </b> (String)
\n<b> One-line description </b>: The AMOEBA polarization type, either direct, mutual, or nonpolarizable.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> ASYNCHRONOUS </b> (Bool)
\n<b> One-line description </b>: Execute Work Queue tasks and local calculations asynchronously for improved speed
\n<b> Default Value </b>: 0
\n<b> Scope </b>: Targets that use Work Queue (Optional)
\n<b> Full description </b>: When using Work Queue to distribute computationally intensive tasks (e.g. condensed phase simulations), 
                                  it is computationally efficient to run the local jobs concurrently rather than wait for the tasks to finish.  Setting
                                  this flag allows local evaluation of targets to proceed while the Work Queue runs in the background, which speeds up
                                  the calculation compared to waiting idly for the Work Queue tasks to complete.
\n<b> Recommendation </b>: If using Work Queue to distribute tasks for some targets, set to True.

@li <b> BACKUP </b> (Bool)
\n<b> One-line description </b>: Write temp directories to backup before wiping them
\n<b> Default Value </b>: 1
\n<b> Scope </b>: All force field optimizations (Optional)

@li <b> CONSTRAIN_CHARGE </b> (Bool)
\n<b> One-line description </b>: Specify whether to constrain the charges on the molecules.
\n<b> Default Value </b>: 0
\n<b> Scope </b>: Force fields with point charges (Optional)
\n<b> Full description </b>: It is important for force fields with point charges to not change the overall charge on the molecule or ion.  Setting this option
                                      will activate a linear transformation which projects out the direction in parameter space that changes the net charge.
\n<b> Recommendation </b>: Either set to true and check your output carefully, or use "eval" statements in the force field file for finer control.

@li <b> CONTINUE </b> (Bool)
\n<b> One-line description </b>: Continue the current run from where we left off (supports mid-iteration recovery).
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> CONVERGENCE_GRADIENT </b> (Float)
\n<b> One-line description </b>: Convergence criterion of gradient norm
\n<b> Default Value </b>: 0.001
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer will quit when the objective function gradient falls below this number.
                                          Since this is a newly implemented option, I can't say when this option will fail.
\n<b> Recommendation </b>: Leave at the default, or set to several orders of magnitude below a typical value of the gradient (perhaps the gradient at the start of the optimization.)

@li <b> CONVERGENCE_OBJECTIVE </b> (Float)
\n<b> One-line description </b>: Convergence criterion of objective function (in MainOptimizer this is the stdev of X2 over [objective_history] steps)
\n<b> Default Value </b>: 0.0001
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer will quit when the last ten good values of the objective function have a
                                           standard deviation that falls below this number.  We use the last ten good values (instead of the latest
                                           change in the objective function), otherwise this condition would be triggered by taking tiny steps.
\n<b> Recommendation </b>: Decrease this value if it's being triggered by small step sizes.

@li <b> CONVERGENCE_STEP </b> (Float)
\n<b> One-line description </b>: Convergence criterion of step size (just needs to fall below this threshold)
\n<b> Default Value </b>: 0.0001
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer will quit when the step size falls below this number.  This happens if we are
                                      approaching a local minimum, or if the optimizer is constantly taking bad steps and the trust radius is
                                      reduced until it falls below this number.  In the latter case, this usually means that the derivatives are
                                      wrong.
\n<b> Recommendation </b>: Make sure that this value is much smaller than trust0.

@li <b> CRITERIA </b> (Int)
\n<b> One-line description </b>: The number of convergence criteria that must be met for main optimizer to converge
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> EIG_LOWERBOUND </b> (Float)
\n<b> One-line description </b>: Minimum eigenvalue for applying steepest descent correction
\n<b> Default Value </b>: 0.0001
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer will misbehave if there are negative or very small eigenvalues in the
                                    objective function Hessian.  In the former case the optimizer will travel toward a saddle point (or
                                    local maximum), and in the latter case the matrix inversion will fail because of the matrix singularity.
                                    If the smallest eigenvalue is below this value, then a multiple of the identity matrix is added to the
                                    Hessian to increase the smallest eigenvalue to at least this value.
\n<b> Recommendation </b>: Shouldn't have to worry about this setting, unless the optimizer appears to be taking bad steps or inverting nearly singular matrices.

@li <b> ERROR_TOLERANCE </b> (Float)
\n<b> One-line description </b>: Error tolerance; the optimizer will only reject steps that increase the objective function by more than this number.
\n<b> Default Value </b>: 0.0
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: In some targets (e.g. condensed phase properties), the contribution to the objective function may contain statistical noise
                                     and cause the optimization step to be rejected.  Introducing an error tolerance allows the optimization to continue despite some apparent
                                     roughness in the objective function surface.
\n<b> Recommendation </b>: Set to zero for targets that don't have statistical noise.  
                                     Otherwise, choose a value based on the rough size of the objective function and the weight of the statistically noisy targets.

@li <b> FFDIR </b> (String)
\n<b> One-line description </b>: Directory containing force fields, relative to project directory
\n<b> Default Value </b>: forcefield
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> Recommendation </b>: Unless you're using a nonstandard location for force field files, you probably shouldn't change this.

@li <b> FINITE_DIFFERENCE_FACTOR </b> (Float)
\n<b> One-line description </b>: Make sure that the finite difference step size does not exceed this multiple of the trust radius.
\n<b> Default Value </b>: 0.1
\n(Needs full documentation)

@li <b> FINITE_DIFFERENCE_H </b> (Float)
\n<b> One-line description </b>: Step size for finite difference derivatives in many functions
\n<b> Default Value </b>: 0.001
\n<b> Scope </b>: fdcheck_G or fdcheck_H job types, or whenever the objective function is evaluated using finite difference (Optional)
\n<b> Full description </b>: When the objective function derivatives are checked using finite difference, or when the objective function derivative
                                         requires finite difference, this is the step size that is used (in the mathematical space).  The actual parameter in the
                                         force field is changed by this amount times the rescaling factor.
\n<b> Recommendation </b>: 1e-2 to 1e-4; run FDCheckG to see if derivatives are accurate; if derivatives are inaccurate then adjust accordingly.
                                         If the objective function itself requires finite difference, there will still be a difference because FDCheckG(H) uses an accurate
                                         seven-point (five-point) stencil.  Make sure that the derivatives agree before settling on a value to use.

@li <b> FORCEFIELD </b> (List)
\n<b> One-line description </b>: The names of force fields, corresponding to directory forcefields/file_name.(itp,xml,prm,frcmod,mol2)
\n<b> Default Value </b>: []
\n<b> Scope </b>: All force field optimizations (<b><em>Required</em></b>)

@li <b> GMXPATH </b> (String)
\n<b> One-line description </b>: Path for GROMACS executables (if not the default)
\n<b> Default Value </b>: /home/leeping/opt/gromacs/bin
\n<b> Scope </b>: Targets that use GROMACS (<b><em>Required</em></b>)
\n<b> Full description </b>: Specify the path where GROMACS executables are installed, most likely ending in 'bin'.
                             Note that executables are only installed 'bin' if the program is installed using 'make install';
                             this will NOT be the case if you simply ran 'make'.
\n<b> Recommendation </b>: Depends on your local installation and environment.

@li <b> GMXSUFFIX </b> (String)
\n<b> One-line description </b>: The suffix of GROMACS executables
\n<b> Default Value </b>: 
\n<b> Scope </b>: Targets that use GROMACS (Optional)
\n<b> Full description </b>: Depending on how GROMACS is configured and installed, a suffix may be appended to executable
                               names.  If there is a suffix, it needs to be specified here (or else ForceBalance will not find the
                               GROMACS executable and it will crash.
\n<b> Recommendation </b>: Depends on your local installation and environment.

@li <b> HAVE_VSITE </b> (Bool)
\n<b> One-line description </b>: Specify whether there are virtual sites in the simulation (being fitted or not).  Enforces calculation of vsite positions.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> JOBTYPE </b> (Allcap)
\n<b> One-line description </b>: The calculation type, defaults to a single-point evaluation of objective function.
\n<b> Default Value </b>: single
\n<b> Scope </b>: All force field optimizations (<b><em>Required</em></b>)
\n<b> Full description </b>: Here you may specify the type of ForceBalance job.  This ranges from gradient-based and stochastic
                             optimizations to simple scans over the parameter space and finite difference checking of gradients.
\n<b> Recommendation </b>: See the Optimizer class documentation for which optimizer is best suited for you.

@li <b> LM_GUESS </b> (Float)
\n<b> One-line description </b>: Guess value for bracketing line search in trust radius algorithm
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> LOGARITHMIC_MAP </b> (Bool)
\n<b> One-line description </b>: Optimize in the space of log-variables
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> LQ_CONVERGE </b> (Bool)
\n<b> One-line description </b>: Allow convergence on "low quality" steps
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> MAXSTEP </b> (Int)
\n<b> One-line description </b>: Maximum number of steps in an optimization
\n<b> Default Value </b>: 100
\n<b> Scope </b>: All iterative optimization jobs (Optional)
\n<b> Recommendation </b>: At least 100 optimization steps are recommended.

@li <b> MINTRUST </b> (Float)
\n<b> One-line description </b>: Minimum trust radius (if the trust radius is tiny, then noisy optimizations become really gnarly)
\n<b> Default Value </b>: 0.0
\n(Needs full documentation)

@li <b> NORMALIZE_WEIGHTS </b> (Bool)
\n<b> One-line description </b>: Normalize the weights for the fitting targets
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> OBJECTIVE_HISTORY </b> (Int)
\n<b> One-line description </b>: Number of good optimization steps to average over when checking the objective convergence criterion
\n<b> Default Value </b>: 2
\n(Needs full documentation)

@li <b> PENALTY_ADDITIVE </b> (Float)
\n<b> One-line description </b>: Factor for additive penalty function in objective function
\n<b> Default Value </b>: 0.0
\n<b> Scope </b>: Objective function (Optional)
\n<b> Full description </b>: Add a penalty to the objective function (e.g. L2 or L1 norm) with this prefactor.
                                      Using an additive penalty requires an assessment of the order of magnitude of the objective function,
                                      but it is closer to the statistical concept of ridge or LASSO regression.
\n<b> Recommendation </b>: No recommendation; run a single-point calculation to choose a prefactor.  Consider 0.01
                                      for an objective function of order 1.

@li <b> PENALTY_ALPHA </b> (Float)
\n<b> One-line description </b>: Extra parameter for fusion penalty function.  Dictates position of log barrier or L1-L0 switch distance
\n<b> Default Value </b>: 0.001
\n(Needs full documentation)

@li <b> PENALTY_HYPERBOLIC_B </b> (Float)
\n<b> One-line description </b>: Cusp region for hyperbolic constraint; for x=0, the Hessian is a/2b
\n<b> Default Value </b>: 1e-06
\n(Needs full documentation)

@li <b> PENALTY_MULTIPLICATIVE </b> (Float)
\n<b> One-line description </b>: Factor for multiplicative penalty function in objective function
\n<b> Default Value </b>: 0.0
\n<b> Scope </b>: Objective function (Optional)
\n<b> Full description </b>: Multiply the objective function by (1+X) where X is this value.
                                            Using an multiplicative penalty works well for objective functions of any size but it is not
                                            equivalent to statistical regularization methods.
\n<b> Recommendation </b>: A value of 0.01 tends to keep the length of the parameter vector from exceeding 1.

@li <b> PENALTY_TYPE </b> (String)
\n<b> One-line description </b>: Type of the penalty, L2 or Hyp in the optimizer
\n<b> Default Value </b>: L2
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> Full description </b>: To prevent the optimization from changing the parameters too much, an additional penalty
                                  is applied to the objective function that depends linearly (L1) or quadratically (L2) on the norm
                                  of the parameter displacement vector.  L1 corresponds to LASSO regularization while L2 is known as
                                  Tikhonov regularization or ridge regression.
\n<b> Recommendation </b>: L2; tested and known to be working.  Implementation of L1 in progress.

@li <b> PRINT_GRADIENT </b> (Bool)
\n<b> One-line description </b>: Print the objective function gradient at every step
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> PRINT_HESSIAN </b> (Bool)
\n<b> One-line description </b>: Print the objective function Hessian at every step
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> PRINT_PARAMETERS </b> (Bool)
\n<b> One-line description </b>: Print the mathematical and physical parameters at every step
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> PRIORS </b> (Section)
\n<b> One-line description </b>: Paste priors into the input file for them to be read in directly
\n<b> Default Value </b>: OrderedDict()
\n(Needs full documentation)

@li <b> READ_MVALS </b> (Section)
\n<b> One-line description </b>: Paste mathematical parameters into the input file for them to be read in directly
\n<b> Default Value </b>: None
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> Full description </b>: Read in mathematical parameters before starting the optimization.  There is a standardized syntax, given by:
@verbatim read_mvals
0 [ -2.9766e-01 ] : VDWSOW
1 [  2.2283e-01 ] : VDWTOW
2 [ -1.1138e-03 ] : BONDSBHWOW
3 [ -9.0883e-02 ] : BONDSKHWOW
\read_mvals @endverbatim
\n<b> Recommendation </b>: If you run the main optimizer, it will print out this block at the very end for you to use and/or modify.

@li <b> READ_PVALS </b> (Section)
\n<b> One-line description </b>: Paste physical parameters into the input file for them to be read in directly
\n<b> Default Value </b>: None
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> Full description </b>: Read in physical parameters before starting the optimization.  There is a standardized
                                syntax, given by:
@verbatim read_pvals
 0 [  2.9961e-01 ] : VDWSOW
 1 [  1.2009e+00 ] : VDWTOW
 2 [  9.5661e-02 ] : BONDSBHWOW
 3 [  4.1721e+05 ] : BONDSKHWOW
 \read_pvals @endverbatim
                                These are the actual numbers that go into the force field file, so note the large changes in magnitude.
\n<b> Recommendation </b>: If you run the main optimizer, it will print out this block at the very end for you to use and/or modify.

@li <b> READCHK </b> (String)
\n<b> One-line description </b>: Name of the restart file we read from
\n<b> Default Value </b>: None
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer has the ability to pick up where it left off by reading / writing checkpoint
                             files.  Here you may specify the checkpoint file to read in from a previous optimization run.  This is
                             equivalent to reading in stored parameter values, except the gradient and Hessian (which contains memory from previous
                             steps) is recorded too.

@li <b> REEVALUATE </b> (Bool)
\n<b> One-line description </b>: Re-evaluate the objective function and gradients when the step is rejected (for noisy objective functions).
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> RIGID_WATER </b> (Bool)
\n<b> One-line description </b>: Perform calculations using rigid water molecules.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> RPMD_BEADS </b> (Int)
\n<b> One-line description </b>: Number of beads in ring polymer MD (zero to disable)
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> SCAN_VALS </b> (String)
\n<b> One-line description </b>: Values to scan in the parameter space, given like this: -0.1:0.1:11
\n<b> Default Value </b>: None
\n<b> Scope </b>: scan_mvals and scan_pvals job types (Optional)
\n<b> Full description </b>: This specifies a range of parameter values to scan in a uniform grid.  scan_mvals works in
                               the mathematical parameter space while scan_pvals works in the physical parameter space.  The syntax
                               is lower:step:upper .  Both lower and upper limits are included in the range.
\n<b> Recommendation </b>: For scan_mvals, a range of values between -1 and +1 is recommended; for scan_pvals, choose values close to the physical parameter value.

@li <b> SCANINDEX_NAME </b> (List)
\n<b> One-line description </b>: Parameter name to scan over (should convert to a numerical index)
\n<b> Default Value </b>: []
\n<b> Scope </b>: scan_mvals and scan_pvals job types (Optional)
\n<b> Full description </b>: ForceBalance assigns to each adjustable parameter a 'parameter name'.  By specifying
                                    this option, this tells the parameter scanner to locate the correct parameter with the specified name and then
                                    scan over it.
\n<b> Recommendation </b>: Look at the printout from a single-point job to determine the parameter names.

@li <b> SCANINDEX_NUM </b> (List)
\n<b> One-line description </b>: Numerical index of the parameter to scan over
\n<b> Default Value </b>: []
\n<b> Scope </b>: scan_mvals and scan_pvals job types (Optional)
\n<b> Full description </b>: ForceBalance assigns to each adjustable parameter a 'parameter number' corresponding to
                                   its position in the parameter vector.  This tells the parameter scanner which number to scan over.
\n<b> Recommendation </b>: Look at the printout from a single-point job to decide which parameter number you wish to scan over.

@li <b> SEARCH_TOLERANCE </b> (Float)
\n<b> One-line description </b>: Search tolerance; used only when trust radius is negative, dictates convergence threshold of nonlinear search.
\n<b> Default Value </b>: 0.0001
\n(Needs full documentation)

@li <b> STEP_LOWERBOUND </b> (Float)
\n<b> One-line description </b>: Optimization will "fail" if step falls below this size
\n<b> Default Value </b>: 1e-06
\n(Needs full documentation)

@li <b> TINKERPATH </b> (String)
\n<b> One-line description </b>: Path for TINKER executables (if not the default)
\n<b> Default Value </b>: /home/leeping/opt/tinker/bin
\n<b> Scope </b>: Targets that use TINKER (<b><em>Required</em></b>)
\n<b> Recommendation </b>: Depends on your local installation and environment.

@li <b> TRUST0 </b> (Float)
\n<b> One-line description </b>: Levenberg-Marquardt trust radius; set to negative for nonlinear search
\n<b> Default Value </b>: 0.1
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer uses a trust radius which 'adapts' (i.e. increases or decreases) based on whether the last step
                            was a good or bad step.  'trust0' provides the starting trust radius, and the trust radius is not allowed to increase too much
                            from trust0.
\n<b> Recommendation </b>: Increase from the default if the optimizer takes many good steps but takes too long; decrease if the optimizer takes many bad steps.

@li <b> USE_PVALS </b> (Bool)
\n<b> One-line description </b>: Bypass the transformation matrix and use the physical parameters directly
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> VERBOSE_OPTIONS </b> (Bool)
\n<b> One-line description </b>: Set to false to suppress printing options that are equal to their defaults
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> WQ_PORT </b> (Int)
\n<b> One-line description </b>: The port number to use for Work Queue
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> WRITECHK </b> (String)
\n<b> One-line description </b>: Name of the restart file we write to (can be same as readchk)
\n<b> Default Value </b>: None
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> Full description </b>: The main optimizer has the ability to pick up where it left off by reading / writing checkpoint
                              files.  Here you may specify the checkpoint file to write after the job is finished.
\n<b> Recommendation </b>: Writing the checkpoint file is highly recommended.

@li <b> WRITECHK_STEP </b> (Bool)
\n<b> One-line description </b>: Write the checkpoint file at every optimization step
\n<b> Default Value </b>: 1
\n<b> Scope </b>: Main optimizer when 'writechk' is turned on (Optional)
\n<b> Full description </b>: Write a checkpoint file every single step, not just after the job is finished.
\n<b> Recommendation </b>: Useful if you want to quit an optimization before it finishes and restart, but make sure you don't overwrite existing checkpoint files by accident.

@li <b> ZEROGRAD </b> (Int)
\n<b> One-line description </b>: Set to a nonnegative number to turn on zero gradient skipping at that optimization step.
\n<b> Default Value </b>: -1
\n(Needs full documentation)

\section tgt_option_index Option index: Target options

This section contains a listing of the target options available when running
a ForceBalance job, which go into the $tgt_opts section.  There can be multiple 
$tgt_opts sections in a ForceBalance input file, one for each target.

@li <b> ABSOLUTE </b> (Bool)
\n<b> One-line description </b>: When matching energies in AbInitio, do not subtract the mean energy gap.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> ADAPT_ERRORS </b> (Bool)
\n<b> One-line description </b>: Adapt to simulation uncertainty by combining property estimations and adjusting simulation length.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> ALL_AT_ONCE </b> (Bool)
\n<b> One-line description </b>: Compute all energies and forces in one fell swoop where possible(as opposed to calling the simulation code once per snapshot)
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> ANISOTROPIC_BOX </b> (Bool)
\n<b> One-line description </b>: Enable anisotropic box scaling (e.g. for crystals or two-phase simulations) in external npt.py script
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> ATTENUATE </b> (Bool)
\n<b> One-line description </b>: Normalize interaction energies using 1/(denom**2 + reference**2) only for repulsive interactions greater than denom.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> BATCH_FD </b> (Bool)
\n<b> One-line description </b>: Whether to batch and queue up finite difference jobs, defaults to False
\n<b> Default Value </b>: 0
\n<b> Scope </b>: All target types (Optional)
\n<b> Full description </b>: This is a stub for future functionality.  When the flag is switched on, the jobs corresponding to finite
                              difference derivatives are evaluated in parallel on a distributed computing platform.

@li <b> CAUCHY </b> (Bool)
\n<b> One-line description </b>: Normalize interaction energies each using 1/(denom**2 + reference**2) which resembles a Cauchy distribution
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> COORDS </b> (String)
\n<b> One-line description </b>: Coordinates for single point evaluation; if not provided, will search for a default.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> COVARIANCE </b> (Bool)
\n<b> One-line description </b>: Whether to use the quantum covariance matrix
\n<b> Default Value </b>: 0
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> Full description </b>: The components of the energy and force contribution to the objective function are rescaled to be on the 
                                same footing when the objective function is optimized.  This can be done by dividing each component by its variance,
                                or by multiplying the energy-force polytensor by the inverse of the quantum energy-force covariance matrix.  The
                                latter method was proposed as a way to emphasize intermolecular interactions but it is unproven.
\n<b> Recommendation </b>: No recommendation; turn the covariance off if the number of snapshots is not much larger than
                                the number of coordinates.

@li <b> DIPOLE_DENOM </b> (Float)
\n<b> One-line description </b>: Dipole normalization (Debye) ; set to 0 if a zero weight is desired
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> DO_COSMO </b> (Bool)
\n<b> One-line description </b>: Call Q-Chem to do MM COSMO on MM snapshots.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> ENERGY </b> (Bool)
\n<b> One-line description </b>: Enable the energy objective function
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> ENERGY_DENOM </b> (Float)
\n<b> One-line description </b>: Energy normalization for binding energies in kcal/mol (default is to use stdev)
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> ENERGY_UPPER </b> (Float)
\n<b> One-line description </b>: Upper energy cutoff (in kcal/mol); super-repulsive interactions are given zero weight
\n<b> Default Value </b>: 30.0
\n(Needs full documentation)

@li <b> ENGINE </b> (Allcap)
\n<b> One-line description </b>: The external code used to execute the simulations (GMX, TINKER, AMBER, OpenMM)
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> EQ_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the equilibration run.
\n<b> Default Value </b>: 20000
\n(Needs full documentation)

@li <b> EXPDATA_TXT </b> (String)
\n<b> One-line description </b>: Text file containing experimental data.
\n<b> Default Value </b>: expset.txt
\n(Needs full documentation)

@li <b> FD_PTYPES </b> (List)
\n<b> One-line description </b>: The parameter types that are differentiated using finite difference
\n<b> Default Value </b>: []
\n<b> Scope </b>: All target types (Optional)
\n<b> Full description </b>: To compute the objective function derivatives, some components may require numerical finite difference in the derivatives.
                             Here you may specify the parameter types that finite difference is applied to,
                             or write 'ALL' to take finite-difference derivatives in all parameter types.
\n<b> Recommendation </b>: If you aren't sure, either use 'ALL' to do finite difference in each component (this is costly), or run a fdcheckG(H)
                             job with this option set to 'NONE' to check which analytic derivatives are missing.

@li <b> FDGRAD </b> (Bool)
\n<b> One-line description </b>: Finite difference gradient of objective function w/r.t. specified parameters
\n<b> Default Value </b>: 0
\n<b> Scope </b>: All target types (Optional)
\n<b> Full description </b>: When this option is enabled, finite difference gradients will be enabled for selected parameter types 
                            (using the fd_ptypes option).  Gradients are computed using two-point finite difference of the objective function.
\n<b> Recommendation </b>: If analytic derivatives are implemented (and correct), then they are much faster than finite difference
                            derivatives.  Run the 'fdcheckG' routine with this option set to Off to check which finite difference derivatives you need.

@li <b> FDHESS </b> (Bool)
\n<b> One-line description </b>: Finite difference Hessian of objective function w/r.t. specified parameters
\n<b> Default Value </b>: 0
\n<b> Scope </b>: All target types (Optional)
\n<b> Full description </b>: When this option is enabled, finite difference Hessians will be enabled for selected parameter types 
                            (using the fd_ptypes option).  Hessians are computed using two-point finite difference of the gradient.
\n<b> Recommendation </b>: Run the 'fdcheckH' routine with this option set to Off to check which finite difference Hessian elements you need.
                            Note that this requires a very large number of objective function evaluations, so use sparingly.

@li <b> FDHESSDIAG </b> (Bool)
\n<b> One-line description </b>: Finite difference Hessian diagonals w/r.t. specified parameters (costs 2np times a objective calculation)
\n<b> Default Value </b>: 0
\n<b> Scope </b>: All target types (Optional)
\n<b> Full description </b>: When this option is enabled, finite difference gradients and Hessian diagonal elements will be enabled 
                                for selected parameter types (using the fd_ptypes option).  This is done using a three-point finite difference of
                                the objective function.
\n<b> Recommendation </b>: Use this as a substitute for 'fdgrad'; it doubles the cost but provides more accurate derivatives
                                plus the Hessian diagonal values (these are very nice for quasi-Newton optimizers like BFGS).

@li <b> FITATOMS </b> (Int)
\n<b> One-line description </b>: Number of fitting atoms; defaults to all of them
\n<b> Default Value </b>: 0
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> Full description </b>: Choose a subset of atoms to fit forces to.  This is useful in situations where
                              it is undesirable to fit the forces on part of the system (e.g. the part that is described by another force field.)
                              Currently, you are only allowed to choose from the atoms in the front of the trajectory;
                              soon this will be expanded for random flexibility (see 'shots').  However, random coordinate selections are not allowed. ;)
\n<b> Recommendation </b>: Situation-dependent; this should be based on the part of the system that you're fitting, or leave blank
                              if you're fitting the whole system.

@li <b> FORCE </b> (Bool)
\n<b> One-line description </b>: Enable the force objective function
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> FORCE_CUDA </b> (Bool)
\n<b> One-line description </b>: Force the external npt.py script to crash if CUDA Platform not available
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> FORCE_MAP </b> (String)
\n<b> One-line description </b>: The resolution of mapping interactions to net forces and torques for groups of atoms.  In order of resolution: molecule > residue > charge-group
\n<b> Default Value </b>: residue
\n(Needs full documentation)

@li <b> FRAGMENT1 </b> (String)
\n<b> One-line description </b>: Interaction fragment 1: a selection of atoms specified using atoms and dashes, e.g. 1-6 to select the first through sixth atom (i.e. list numbering starts from 1)
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> FRAGMENT2 </b> (String)
\n<b> One-line description </b>: Interaction fragment 2: a selection of atoms specified using atoms and dashes, e.g. 7-11 to select atoms 7 through 11.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> GAS_COORDS </b> (String)
\n<b> One-line description </b>: Provide file name for gas phase coordinates.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> GAS_EQ_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the gas equilibration run, if different from default.
\n<b> Default Value </b>: 10000
\n(Needs full documentation)

@li <b> GAS_INTERVAL </b> (Float)
\n<b> One-line description </b>: Time interval for saving coordinates for the gas production run (if zero, use default in external script.)
\n<b> Default Value </b>: 0.1
\n(Needs full documentation)

@li <b> GAS_MD_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the gas production run, if different from default.
\n<b> Default Value </b>: 100000
\n(Needs full documentation)

@li <b> GAS_TIMESTEP </b> (Float)
\n<b> One-line description </b>: Time step size for the gas simulation (if zero, use default in external script.).
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> GMX_MDP </b> (String)
\n<b> One-line description </b>: Gromacs .mdp files.  If not provided, will search for default.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> GMX_NDX </b> (String)
\n<b> One-line description </b>: Gromacs .ndx files.  If not provided, will search for default.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> GMX_TOP </b> (String)
\n<b> One-line description </b>: Gromacs .top files.  If not provided, will search for default.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> HVAP_SUBAVERAGE </b> (Bool)
\n<b> One-line description </b>: Don't target the average enthalpy of vaporization and allow it to freely float (experimental)
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> INTER_TXT </b> (String)
\n<b> One-line description </b>: Text file containing interacting systems.  If not provided, will search for a default.
\n<b> Default Value </b>: interactions.txt
\n(Needs full documentation)

@li <b> LIPID_COORDS </b> (String)
\n<b> One-line description </b>: Provide file name for lipid coordinates.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> LIPID_EQ_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the lipid equilibration run.
\n<b> Default Value </b>: 1000
\n(Needs full documentation)

@li <b> LIPID_INTERVAL </b> (Float)
\n<b> One-line description </b>: Time interval for saving coordinates for the lipid production run.
\n<b> Default Value </b>: 0.1
\n(Needs full documentation)

@li <b> LIPID_MD_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the lipid production run.
\n<b> Default Value </b>: 10000
\n(Needs full documentation)

@li <b> LIPID_TIMESTEP </b> (Float)
\n<b> One-line description </b>: Time step size for the lipid simulation.
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> LIQUID_COORDS </b> (String)
\n<b> One-line description </b>: Provide file name for condensed phase coordinates.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> LIQUID_EQ_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the liquid equilibration run.
\n<b> Default Value </b>: 1000
\n(Needs full documentation)

@li <b> LIQUID_INTERVAL </b> (Float)
\n<b> One-line description </b>: Time interval for saving coordinates for the liquid production run.
\n<b> Default Value </b>: 0.1
\n(Needs full documentation)

@li <b> LIQUID_MD_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the liquid production run.
\n<b> Default Value </b>: 10000
\n(Needs full documentation)

@li <b> LIQUID_TIMESTEP </b> (Float)
\n<b> One-line description </b>: Time step size for the liquid simulation.
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> MANUAL </b> (Bool)
\n<b> One-line description </b>: Give the user a chance to fill in condensed phase stuff on the zeroth step
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> MD_STEPS </b> (Int)
\n<b> One-line description </b>: Number of time steps for the production run.
\n<b> Default Value </b>: 50000
\n(Needs full documentation)

@li <b> MD_THREADS </b> (Int)
\n<b> One-line description </b>: Set the number of threads used by Gromacs or TINKER processes in MD simulations
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> MINIMIZE_ENERGY </b> (Bool)
\n<b> One-line description </b>: Minimize the energy of the system prior to running dynamics
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> MTS_INTEGRATOR </b> (Bool)
\n<b> One-line description </b>: Enable multiple-timestep integrator in external npt.py script
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> N_MCBAROSTAT </b> (Int)
\n<b> One-line description </b>: Number of steps in the liquid simulation between MC barostat volume adjustments.
\n<b> Default Value </b>: 25
\n(Needs full documentation)

@li <b> N_SIM_CHAIN </b> (Int)
\n<b> One-line description </b>: Number of simulations required to calculate quantities.
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> NAME </b> (String)
\n<b> One-line description </b>: The name of the target, corresponding to the directory targets/name
\n<b> Default Value </b>: None
\n<b> Scope </b>: All targets (<b><em>Required</em></b>)
\n<b> Recommendation </b>: Choose a descriptive name and make sure all targets have different names.

@li <b> OPENMM_PLATFORM </b> (String)
\n<b> One-line description </b>: OpenMM platform.  Choose either Reference, CUDA or OpenCL.  AMOEBA is on Reference or CUDA only.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> OPENMM_PRECISION </b> (String)
\n<b> One-line description </b>: Precision of OpenMM calculation if using CUDA or OpenCL platform.  Choose either single, double or mixed ; defaults to the OpenMM default.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> OPTIMIZE_GEOMETRY </b> (Bool)
\n<b> One-line description </b>: Perform a geometry optimization before computing properties
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> PDB </b> (String)
\n<b> One-line description </b>: PDB file mainly used for building OpenMM systems but can also contain coordinates.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> POLARIZABILITY_DENOM </b> (Float)
\n<b> One-line description </b>: Dipole polarizability tensor normalization (cubic Angstrom) ; set to 0 if a zero weight is desired
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> QDATA_TXT </b> (String)
\n<b> One-line description </b>: Text file containing quantum data.  If not provided, will search for a default (qdata.txt).
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> QMBOLTZ </b> (Float)
\n<b> One-line description </b>: Fraction of Quantum Boltzmann Weights (ab initio), 1.0 for full reweighting, 0.5 for hybrid
\n<b> Default Value </b>: 0.0
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> Full description </b>: When Boltzmann sampling is used to gather snapshots for force/energy matching, there is a potential
                             ambiguity regarding which ensemble one should sample from (either the force field's ensemble or the QM calculation's
                             ensemble.  The QM ensemble may be sampled using MM-sampled snapshots by reweighting; this tuning parameter specifies
                             the fraction of QM Boltzmann weight to include.  Note that when two ensembles are different, reweighting will decrease
                             the statistical significance of the number of snapshots (i.e. there is less InfoContent).
\n<b> Recommendation </b>: If you want to reweight your snapshots entirely to the QM ensemble, choose 1.0; for hybrid weights,
                             use 0.5.  Avoid if the there is a very large RMS energy difference between QM and MM.

@li <b> QMBOLTZTEMP </b> (Float)
\n<b> One-line description </b>: Temperature for Quantum Boltzmann Weights (ab initio), defaults to room temperature
\n<b> Default Value </b>: 298.15
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> Full description </b>: The reweighting of an ensemble involves an exponential of (DE)/kT, so there is a massive degradation of sample
                                 quality if (DE) is large.  This option allows you to change the temperature in the denominator, which is unphysical (but
                                 it does decrease the effect of moving toward the QM ensemble.
\n<b> Recommendation </b>: Irrelevant if 'qmboltz' is set to zero.  Leave at the default value unless you're performing experiments.

@li <b> QUADRUPOLE_DENOM </b> (Float)
\n<b> One-line description </b>: Quadrupole normalization (Buckingham) ; set to 0 if a zero weight is desired
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> QUANTITIES </b> (List)
\n<b> One-line description </b>: List of quantities to be fitted, each must have corresponding Quantity subclass
\n<b> Default Value </b>: []
\n(Needs full documentation)

@li <b> READ </b> (String)
\n<b> One-line description </b>: Provide a temporary directory ".tmp" to read data from a previous calculation on the initial iteration (for instance, to restart an aborted run).
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> REASSIGN_MODES </b> (String)
\n<b> One-line description </b>: Reassign modes before fitting frequencies, using either linear assignment "permute" or maximum overlap "overlap".
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> REMOTE </b> (Bool)
\n<b> One-line description </b>: Evaluate target as a remote work_queue task
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> RESP </b> (Bool)
\n<b> One-line description </b>: Enable the RESP objective function
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> RESP_A </b> (Float)
\n<b> One-line description </b>: RESP "a" parameter for strength of penalty; 0.001 is strong, 0.0005 is weak
\n<b> Default Value </b>: 0.001
\n(Needs full documentation)

@li <b> RESP_B </b> (Float)
\n<b> One-line description </b>: RESP "b" parameter for hyperbolic behavior; 0.1 is recommended
\n<b> Default Value </b>: 0.1
\n(Needs full documentation)

@li <b> RMSD_DENOM </b> (Float)
\n<b> One-line description </b>: RMSD normalization for optimized geometries in Angstrom
\n<b> Default Value </b>: 0.1
\n(Needs full documentation)

@li <b> RUN_INTERNAL </b> (Bool)
\n<b> One-line description </b>: For OpenMM or other codes with Python interface: Compute energies and forces internally
\n<b> Default Value </b>: 1
\n(Needs full documentation)

@li <b> SAMPCORR </b> (Bool)
\n<b> One-line description </b>: Whether to use the archaic sampling correction
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> SAVE_TRAJ </b> (Int)
\n<b> One-line description </b>: Whether to save trajectories.  0 = Never save; 1 = Delete if optimization step is good; 2 = Always save
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> SELF_POL_ALPHA </b> (Float)
\n<b> One-line description </b>: Polarizability parameter for self-polarization correction (in debye).
\n<b> Default Value </b>: 0.0
\n(Needs full documentation)

@li <b> SELF_POL_MU0 </b> (Float)
\n<b> One-line description </b>: Gas-phase dipole parameter for self-polarization correction (in debye).
\n<b> Default Value </b>: 0.0
\n(Needs full documentation)

@li <b> SHOTS </b> (Int)
\n<b> One-line description </b>: Number of snapshots; defaults to all of the snapshots
\n<b> Default Value </b>: -1
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> Full description </b>: This option allows you to choose a subset from the snapshots available in the force matching 'targets' directory.
                           The subset is simply taken from the front of the trajectory.
                           In the future this option will be expanded to allow a random selection of snapshots, or a specific selection
\n<b> Recommendation </b>: 100-10,000 snapshots are recommended.  Note that you need at least 3x (number of atoms) if
                           the covariance matrix is turned on.

@li <b> SLEEPY </b> (Int)
\n<b> One-line description </b>: Wait a number of seconds every time this target is visited (gives me a chance to ctrl+C)
\n<b> Default Value </b>: 0
\n(Needs full documentation)

@li <b> TINKER_KEY </b> (String)
\n<b> One-line description </b>: TINKER .key files.  If not provided, will search for default.
\n<b> Default Value </b>: None
\n(Needs full documentation)

@li <b> TYPE </b> (Allcap)
\n<b> One-line description </b>: The type of fitting target, for instance AbInitio_GMX ; this must correspond to the name of a Target subclass.
\n<b> Default Value </b>: None
\n<b> Scope </b>: All targets (<b><em>Required</em></b>)
\n<b> Full description </b>: This is the type of target that you are running.  The current accepted values for the target type
                             are given in the beginning of the objective.py file: INTERACTION_OPENMM, LIQUID_OPENMM, MOMENTS_GMX, BINDINGENERGY_TINKER, BINDINGENERGY_GMX, VIBRATION_GMX, ABINITIO_AMBER, THERMO_GMX, ABINITIO_TINKER, MOMENTS_OPENMM, ABINITIO_INTERNAL, LIPID_GMX, LIQUID_GMX, COUNTERPOISE, ABINITIO_OPENMM, RDVR3_PSI4, MOMENTS_TINKER, THCDF_PSI4, INTERACTION_TINKER, ABINITIO_GMX, BINDINGENERGY_OPENMM, INTERACTION_GMX, REMOTE_TARGET, VIBRATION_TINKER, LIQUID_TINKER.
\n<b> Recommendation </b>: Choose the appropriate type, and if the target type is missing, feel free to implement your own (or ask me for help).

@li <b> W_AL </b> (Float)
\n<b> One-line description </b>: Weight of average area per lipid
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_ALPHA </b> (Float)
\n<b> One-line description </b>: Weight of thermal expansion coefficient
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_CP </b> (Float)
\n<b> One-line description </b>: Weight of isobaric heat capacity
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_ENERGY </b> (Float)
\n<b> One-line description </b>: Weight of energy
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_EPS0 </b> (Float)
\n<b> One-line description </b>: Weight of dielectric constant
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_FORCE </b> (Float)
\n<b> One-line description </b>: Weight of atomistic forces
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_HVAP </b> (Float)
\n<b> One-line description </b>: Weight of enthalpy of vaporization
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_KAPPA </b> (Float)
\n<b> One-line description </b>: Weight of isothermal compressibility
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_NETFORCE </b> (Float)
\n<b> One-line description </b>: Weight of net forces (condensed to molecules, residues, or charge groups)
\n<b> Default Value </b>: 0.0
\n(Needs full documentation)

@li <b> W_RESP </b> (Float)
\n<b> One-line description </b>: Weight of RESP
\n<b> Default Value </b>: 0.0
\n(Needs full documentation)

@li <b> W_RHO </b> (Float)
\n<b> One-line description </b>: Weight of experimental density
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_SCD </b> (Float)
\n<b> One-line description </b>: Weight of dielectric constant
\n<b> Default Value </b>: 1.0
\n(Needs full documentation)

@li <b> W_TORQUE </b> (Float)
\n<b> One-line description </b>: Weight of torques (condensed to molecules, residues, or charge groups)
\n<b> Default Value </b>: 0.0
\n(Needs full documentation)

@li <b> WAVENUMBER_TOL </b> (Float)
\n<b> One-line description </b>: Frequency normalization (in wavenumber) for vibrational frequencies
\n<b> Default Value </b>: 10.0
\n(Needs full documentation)

@li <b> WEIGHT </b> (Float)
\n<b> One-line description </b>: Weight of the target (determines its importance vs. other targets)
\n<b> Default Value </b>: 1.0
\n<b> Scope </b>: All target types (Optional)
\n<b> Full description </b>: This option specifies the weight that the target will contribute to the objective function.
                            A larger weight for a given target means that the optimizer will prioritize it over the others.
                            When several targets are used, the weight should be chosen carefully such that all targets
                            contribute a finite amount to the objective function.  Note that the choice of weight determines the final outcome
                            of the force field, although we hope not by too much.
\n<b> Recommendation </b>: It is important to specify something here (giving everything equal weight is unlikely to work.)  
                            Run a single-point objective function evaluation with all weights set to one to get a handle on
                            the natural size of each target's contribution, and then add weights accordingly.

@li <b> WHAMBOLTZ </b> (Bool)
\n<b> One-line description </b>: Whether to use WHAM Boltzmann Weights
\n<b> Default Value </b>: 0
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> Full description </b>: In self-consistent energy/force matching projects, the data from previous cycles can be reused by applying the
                               Weighted Histogram Analysis Method (WHAM).  However, the WHAM data is currently generated by external scripts that
                               haven't made it into this distribution yet.  In the future, generation of WHAM data will be incorporated into this
                               program automatically.
\n<b> Recommendation </b>: Leave off unless you have an externally generated wham-master.txt and wham-weights.txt files.

@li <b> WRITELEVEL </b> (Int)
\n<b> One-line description </b>: Affects the amount of data being printed to the temp directory.
\n<b> Default Value </b>: 0
\n(Needs full documentation)

